<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="screen-orientation" content="portrait">
    <title>DYlike - ë””ì™€ì´ì‚°ì—…ê°œë°œ ìŠˆíŒ… ê²Œì„</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-text-size-adjust: none;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100dvh; /* dynamic viewport height for mobile address bar */
        }

        #gameContainer {
            position: relative;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            min-height: 0; /* flex child overflow fix */
        }

        canvas {
            display: block;
            border: 2px solid #0ff;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
            cursor: pointer;
            /* width/height set by JS */
        }
        canvas:focus { outline: none; }

        .ui {
            position: absolute;
            top: 4px; left: 8px; right: 8px;
            display: flex;
            justify-content: space-between;
            color: #0ff;
            font-size: 13px;
            text-shadow: 0 0 8px #0ff;
            pointer-events: none;
            z-index: 5;
        }

        #fullscreenBtn {
            position: absolute;
            top: 4px; right: 4px;
            width: 32px; height: 32px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #0ff;
            color: #0ff;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #fullscreenBtn:hover, #fullscreenBtn:active {
            background: rgba(0,255,255,0.3);
        }

        /* ====== í„°ì¹˜ ì»¨íŠ¸ë¡¤ ====== */
        #touchControls {
            display: none;
            width: 100%;
            flex-shrink: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), rgba(0,0,0,1));
            border-top: 1px solid rgba(0,255,255,0.2);
            padding: 8px 12px;
            padding-bottom: max(8px, env(safe-area-inset-bottom));
            justify-content: space-between;
            align-items: center;
        }
        #touchControls.active {
            display: flex;
        }

        .touch-left, .touch-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .touch-right {
            flex-wrap: wrap;
            justify-content: flex-end;
            gap: 6px;
        }

        .touch-btn {
            width: 64px; height: 64px;
            border-radius: 50%;
            background: rgba(0,255,255,0.12);
            border: 2px solid rgba(0,255,255,0.4);
            color: #0ff;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: background 0.1s, transform 0.1s;
        }
        .touch-btn:active, .touch-btn.pressed {
            background: rgba(0,255,255,0.45);
            border-color: #0ff;
            transform: scale(0.92);
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
        }
        .touch-btn.fire {
            width: 80px; height: 80px;
            background: rgba(255,136,0,0.15);
            border-color: rgba(255,136,0,0.5);
            color: #f80;
            font-size: 15px;
            font-weight: bold;
        }
        .touch-btn.fire:active, .touch-btn.fire.pressed {
            background: rgba(255,136,0,0.5);
            border-color: #f80;
            box-shadow: 0 0 20px rgba(255,136,0,0.6);
        }
        .touch-btn.skill {
            width: 52px; height: 52px;
            font-size: 16px;
            background: rgba(255,255,0,0.08);
            border-color: rgba(255,255,0,0.3);
            color: #ff0;
        }
        .touch-btn.skill:active, .touch-btn.skill.pressed {
            background: rgba(255,255,0,0.4);
            border-color: #ff0;
            box-shadow: 0 0 15px rgba(255,255,0,0.5);
        }

        /* ê°€ë¡œëª¨ë“œ ê²½ê³  */
        #landscapeWarning {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #0ff;
            font-size: 18px;
            text-align: center;
            gap: 20px;
        }
        #landscapeWarning .rotate-icon {
            font-size: 60px;
            animation: rotateAnim 2s ease-in-out infinite;
        }
        @keyframes rotateAnim {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* ì „ì²´í™”ë©´ */
        :fullscreen, :-webkit-full-screen {
            background: #000 !important;
        }

        @media (max-height: 500px) and (orientation: landscape) {
            #landscapeWarning { display: flex !important; }
            #gameContainer, #touchControls { display: none !important; }
        }
    </style>
</head>
<body>
    <!-- ê°€ë¡œëª¨ë“œ ê²½ê³  -->
    <div id="landscapeWarning">
        <div class="rotate-icon">ğŸ“±</div>
        <div>ì„¸ë¡œ ëª¨ë“œë¡œ ì „í™˜í•´ì£¼ì„¸ìš”!</div>
        <div style="font-size:14px; color:#888;">Please rotate to portrait mode</div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="480" height="640" tabindex="0"></canvas>
        <div class="ui" id="gameUI">
            <span id="score">SCORE: 0</span>
            <span id="lives">LIVES: â™¥â™¥â™¥</span>
            <span id="level">LEVEL: 1</span>
        </div>
        <button id="fullscreenBtn" title="ì „ì²´í™”ë©´">â›¶</button>
    </div>

    <!-- ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ -->
    <div id="touchControls">
        <div class="touch-left">
            <div class="touch-btn" id="btnLeft">â—€</div>
            <div class="touch-btn" id="btnRight">â–¶</div>
        </div>
        <div class="touch-right">
            <div class="touch-btn skill" id="btnSkillZ">Z</div>
            <div class="touch-btn skill" id="btnSkillX">X</div>
            <div class="touch-btn skill" id="btnSkillC">C</div>
            <div class="touch-btn fire" id="btnFire">FIRE</div>
        </div>
    </div>

    <script>
        // ========================================
        // ì´ˆê¸° ì„¤ì • & ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
        // ========================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const gameContainer = document.getElementById('gameContainer');
        const touchControls = document.getElementById('touchControls');

        // í„°ì¹˜ ë””ë°”ì´ìŠ¤ ê°ì§€ (UA + ê¸°ëŠ¥ ê°ì§€ ëª¨ë‘)
        const isTouchDevice = ('ontouchstart' in window) ||
            (navigator.maxTouchPoints > 0) ||
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (isTouchDevice) {
            touchControls.classList.add('active');
        }

        // ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ (í™”ë©´ì— ë§ê²Œ CSS í¬ê¸° ì¡°ì •, ë‚´ë¶€ í•´ìƒë„ëŠ” 480x640 ìœ ì§€)
        function resizeCanvas() {
            const controlsH = touchControls.classList.contains('active') ? touchControls.offsetHeight : 0;
            const availW = window.innerWidth;
            const availH = window.innerHeight - controlsH;
            const ratio = canvas.width / canvas.height; // 0.75

            let displayW, displayH;
            if (availW / availH < ratio) {
                displayW = availW - 4;
                displayH = displayW / ratio;
            } else {
                displayH = availH - 4;
                displayW = displayH * ratio;
            }

            canvas.style.width = Math.floor(displayW) + 'px';
            canvas.style.height = Math.floor(displayH) + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));
        resizeCanvas();

        // ìë™ í¬ì»¤ìŠ¤
        canvas.focus();

        // ========================================
        // ì „ì²´í™”ë©´ í† ê¸€
        // ========================================
        document.getElementById('fullscreenBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFullscreen();
        });

        function toggleFullscreen() {
            const el = document.documentElement; // ì „ì²´ í˜ì´ì§€ fullscreen (ì»¨íŠ¸ë¡¤ í¬í•¨)
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
            setTimeout(resizeCanvas, 300);
        }

        // ì „ì²´í™”ë©´ ì „í™˜ ì‹œ ë¦¬ì‚¬ì´ì¦ˆ
        document.addEventListener('fullscreenchange', () => setTimeout(resizeCanvas, 200));
        document.addEventListener('webkitfullscreenchange', () => setTimeout(resizeCanvas, 200));

        // ========================================
        // 1ë‹¨ê³„: ì„±ëŠ¥ ìµœì í™”
        // ========================================
        const glowCache = {};
        function getGlowSprite(key, width, height, drawFn) {
            if (glowCache[key]) return glowCache[key];
            const offCanvas = document.createElement('canvas');
            const pad = 30;
            offCanvas.width = width + pad * 2;
            offCanvas.height = height + pad * 2;
            const offCtx = offCanvas.getContext('2d');
            offCtx.translate(pad, pad);
            drawFn(offCtx);
            glowCache[key] = { canvas: offCanvas, pad: pad };
            return glowCache[key];
        }

        const LIMITS = {
            playerBullets: 15,
            enemyBullets: 20,
            particles: 80,
            skillEffects: 30
        };

        let lastTime = 0;
        let deltaTime = 0;

        // ========================================
        // 2ë‹¨ê³„: ìºë¦­í„° ë°ì´í„° ì •ì˜
        // ========================================
        const CHARACTERS = {
            dredger: {
                name: 'ì¤€ì„¤ê³µ',
                nameEn: 'Dredger',
                role: 'íƒ±ì»¤/ì„œí¬í„°',
                job: 'í•˜ìˆ˜ê´€Â·ì§‘ìˆ˜ì • ìŠ¬ëŸ¬ì§€ ì œê±°',
                color: '#0ff',
                colorRgb: '0,255,255',
                speed: 5,
                attack: 2,
                health: 4,
                shootCooldown: 250,
                skills: [
                    { name: 'ìŠ¬ëŸ¬ì§€ í¡ì…', nameEn: 'Suction', cooldown: 8000, duration: 2000, key: 'Z',
                      desc: 'ì „ë°© ë¶€ì±„ê¼´ ì  íƒ„í™˜ í¡ìˆ˜' },
                    { name: 'ìˆ˜ì••í¬', nameEn: 'Water Cannon', cooldown: 12000, duration: 500, key: 'X',
                      desc: 'ì „ë°© ê´€í†µ ë¬¼ì¤„ê¸°' },
                    { name: 'ë…ê°€ìŠ¤ ë°©ë²½', nameEn: 'Gas Shield', cooldown: 15000, duration: 3000, key: 'C',
                      desc: '3ì´ˆê°„ ë¬´ì  ë³´í˜¸ë§‰' }
                ]
            },
            cleaner: {
                name: 'ì„¸ì •ê³µ',
                nameEn: 'Cleaner',
                role: 'ë”œëŸ¬/ê³µê²©ìˆ˜',
                job: 'ì´ˆê³ ì•• ì›Œí„°ì ¯ ì„¸ì •',
                color: '#f80',
                colorRgb: '255,136,0',
                speed: 6,
                attack: 3,
                health: 3,
                shootCooldown: 200,
                skills: [
                    { name: 'í•˜ì´ë“œë¡œ ìºë…¼', nameEn: 'Hydro Cannon', cooldown: 6000, duration: 300, key: 'Z',
                      desc: 'ì´ˆê³ ì•• ê´€í†µ ë ˆì´ì €' },
                    { name: 'ìŠ¤í•€ ì›Œì‹œ', nameEn: 'Spin Wash', cooldown: 10000, duration: 500, key: 'X',
                      desc: '360ë„ íšŒì „ ê³µê²©' },
                    { name: 'ë¶€ì‹ì•¡', nameEn: 'Corrosion', cooldown: 12000, duration: 5000, key: 'C',
                      desc: 'ì‚°ì„± ì›…ë©ì´ ì§€ì† ë°ë¯¸ì§€' }
                ]
            },
            signal: {
                name: 'ì‹ í˜¸ìˆ˜',
                nameEn: 'Signal Person',
                role: 'ì§€íœ˜ê´€/ë²„í¼',
                job: 'í¬ë ˆì¸ ìˆ˜ì‹ í˜¸Â·ìœ„í—˜ ê²½ë³´',
                color: '#f22',
                colorRgb: '255,34,34',
                speed: 7,
                attack: 1,
                health: 3,
                shootCooldown: 300,
                skills: [
                    { name: 'ê¸´ê¸‰ì •ì§€', nameEn: 'Emergency Stop', cooldown: 15000, duration: 2000, key: 'Z',
                      desc: 'ëª¨ë“  ì  2ì´ˆ ì •ì§€' },
                    { name: 'í¬ë ˆì¸ íˆ¬í•˜', nameEn: 'Sky Drop', cooldown: 10000, duration: 800, key: 'X',
                      desc: 'ë²”ìœ„ ëŒ€ë°ë¯¸ì§€ ë‚™í•˜' },
                    { name: 'ì§€íœ˜ ì‹ í˜¸', nameEn: 'Command Signal', cooldown: 12000, duration: 5000, key: 'C',
                      desc: 'ì†ë„+30% ë°œì‚¬ì†ë„+50%' }
                ]
            }
        };

        const CHARACTER_KEYS = ['dredger', 'cleaner', 'signal'];

        // ========================================
        // ê²Œì„ ìƒíƒœ
        // ========================================
        let gameState = 'start';
        let score = 0;
        let lives = 3;
        let maxLives = 3;
        let level = 1;
        let highScore = localStorage.getItem('galaga-highscore') || 0;
        let selectedCharIndex = 0;
        let selectedChar = null;
        let selectAnimTimer = 0;

        const player = {
            x: canvas.width / 2,
            y: canvas.height - 60,
            width: 40,
            height: 40,
            speed: 6,
            color: '#0ff',
            invincible: false,
            invincibleTimer: 0,
            buffed: false,
            buffTimer: 0,
            buffSpeedMult: 1,
            buffFireMult: 1
        };

        let bullets = [];
        let enemies = [];
        let particles = [];
        let enemyBullets = [];
        let stars = [];
        let skillEffects = [];
        let enemyStunTimer = 0;

        let skillCooldowns = [0, 0, 0];
        let skillActive = [false, false, false];
        let skillActiveTimer = [0, 0, 0];

        const keys = {
            left: false,
            right: false,
            space: false,
            z: false,
            x: false,
            c: false
        };

        let lastShot = 0;

        // ========================================
        // ë³„ ë°°ê²½
        // ========================================
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 2 + 0.5
                });
            }
        }

        // ========================================
        // ì  ìƒì„±
        // ========================================
        function spawnEnemies() {
            const rows = Math.min(3 + Math.floor(level / 2), 5);
            const cols = Math.min(6 + Math.floor(level / 3), 10);
            const enemyWidth = 35;
            const enemyHeight = 30;
            const padding = 10;
            const startX = (canvas.width - (cols * (enemyWidth + padding))) / 2;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const type = row === 0 ? 'boss' : (row < 2 ? 'mid' : 'normal');
                    enemies.push({
                        x: startX + col * (enemyWidth + padding),
                        y: 50 + row * (enemyHeight + padding),
                        width: enemyWidth,
                        height: enemyHeight,
                        type: type,
                        health: type === 'boss' ? 2 + Math.floor(level / 3) : 1,
                        color: type === 'boss' ? '#f0f' : (type === 'mid' ? '#ff0' : '#0f0'),
                        moveDir: 1,
                        moveTimer: 0,
                        stunned: false
                    });
                }
            }
        }

        // ========================================
        // ìºë¦­í„° ì™¸í˜• ê·¸ë¦¬ê¸°
        // ========================================
        function drawDredger(drawCtx, x, y, w, h, color, engineFlicker) {
            drawCtx.save();
            drawCtx.translate(x, y);
            drawCtx.shadowColor = color;
            drawCtx.shadowBlur = 15;
            drawCtx.fillStyle = color;
            drawCtx.beginPath();
            drawCtx.moveTo(-w * 0.3, -h * 0.35);
            drawCtx.lineTo(w * 0.3, -h * 0.35);
            drawCtx.lineTo(w * 0.5, h * 0.3);
            drawCtx.lineTo(-w * 0.5, h * 0.3);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.beginPath();
            drawCtx.arc(0, -h * 0.35, w * 0.25, Math.PI, 0);
            drawCtx.fill();
            drawCtx.fillStyle = '#000';
            drawCtx.beginPath();
            drawCtx.arc(0, -h * 0.25, w * 0.12, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.fillStyle = '#fff';
            drawCtx.globalAlpha = 0.8;
            drawCtx.fillRect(-w * 0.18, -h * 0.42, w * 0.36, h * 0.08);
            drawCtx.globalAlpha = 1;
            drawCtx.fillStyle = color;
            drawCtx.fillRect(-w * 0.55, -h * 0.1, w * 0.12, h * 0.35);
            drawCtx.fillRect(w * 0.43, -h * 0.1, w * 0.12, h * 0.35);
            drawCtx.fillRect(-w * 0.4, h * 0.3, w * 0.3, h * 0.15);
            drawCtx.fillRect(w * 0.1, h * 0.3, w * 0.3, h * 0.15);
            drawCtx.fillStyle = '#0ff';
            drawCtx.shadowColor = '#0ff';
            drawCtx.globalAlpha = 0.8;
            const f = engineFlicker || 0;
            drawCtx.beginPath();
            drawCtx.moveTo(-6, h * 0.45);
            drawCtx.quadraticCurveTo(0, h * 0.45 + 18 + f, 6, h * 0.45);
            drawCtx.fill();
            drawCtx.beginPath();
            drawCtx.arc(-8, h * 0.55 + f * 0.5, 3, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.beginPath();
            drawCtx.arc(8, h * 0.52 + f * 0.3, 2, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.globalAlpha = 1;
            drawCtx.restore();
        }

        function drawCleaner(drawCtx, x, y, w, h, color, engineFlicker) {
            drawCtx.save();
            drawCtx.translate(x, y);
            drawCtx.shadowColor = color;
            drawCtx.shadowBlur = 15;
            drawCtx.fillStyle = color;
            drawCtx.beginPath();
            drawCtx.moveTo(0, -h * 0.5);
            drawCtx.lineTo(w * 0.45, -h * 0.15);
            drawCtx.lineTo(w * 0.35, h * 0.35);
            drawCtx.lineTo(-w * 0.35, h * 0.35);
            drawCtx.lineTo(-w * 0.45, -h * 0.15);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.fillStyle = '#000';
            drawCtx.fillRect(-w * 0.2, -h * 0.35, w * 0.4, h * 0.15);
            drawCtx.fillStyle = color;
            drawCtx.globalAlpha = 0.6;
            drawCtx.fillRect(-w * 0.15, -h * 0.33, w * 0.3, h * 0.04);
            drawCtx.globalAlpha = 1;
            drawCtx.fillStyle = color;
            drawCtx.beginPath();
            drawCtx.moveTo(-3, -h * 0.5);
            drawCtx.lineTo(0, -h * 0.65);
            drawCtx.lineTo(3, -h * 0.5);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.strokeStyle = '#000';
            drawCtx.lineWidth = 1.5;
            drawCtx.beginPath();
            drawCtx.moveTo(-w * 0.15, 0);
            drawCtx.lineTo(w * 0.15, 0);
            drawCtx.stroke();
            drawCtx.beginPath();
            drawCtx.moveTo(-w * 0.1, h * 0.12);
            drawCtx.lineTo(w * 0.1, h * 0.12);
            drawCtx.stroke();
            drawCtx.fillStyle = color;
            drawCtx.fillRect(-w * 0.3, h * 0.35, w * 0.22, h * 0.12);
            drawCtx.fillRect(w * 0.08, h * 0.35, w * 0.22, h * 0.12);
            drawCtx.fillStyle = '#f80';
            drawCtx.shadowColor = '#f80';
            drawCtx.globalAlpha = 0.9;
            const f = engineFlicker || 0;
            drawCtx.beginPath();
            drawCtx.moveTo(-8, h * 0.47);
            drawCtx.lineTo(0, h * 0.47 + 20 + f);
            drawCtx.lineTo(8, h * 0.47);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.beginPath();
            drawCtx.moveTo(-12, h * 0.47);
            drawCtx.lineTo(-5, h * 0.47 + 10 + f * 0.7);
            drawCtx.lineTo(-3, h * 0.47);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.beginPath();
            drawCtx.moveTo(3, h * 0.47);
            drawCtx.lineTo(5, h * 0.47 + 10 + f * 0.7);
            drawCtx.lineTo(12, h * 0.47);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.globalAlpha = 1;
            drawCtx.restore();
        }

        function drawSignal(drawCtx, x, y, w, h, color, engineFlicker) {
            drawCtx.save();
            drawCtx.translate(x, y);
            drawCtx.shadowColor = color;
            drawCtx.shadowBlur = 15;
            drawCtx.fillStyle = color;
            drawCtx.beginPath();
            drawCtx.moveTo(0, -h * 0.3);
            drawCtx.lineTo(w * 0.3, h * 0.35);
            drawCtx.lineTo(-w * 0.3, h * 0.35);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.strokeStyle = '#ff0';
            drawCtx.shadowColor = '#ff0';
            drawCtx.lineWidth = 2;
            drawCtx.beginPath();
            drawCtx.moveTo(-w * 0.2, -h * 0.05);
            drawCtx.lineTo(w * 0.15, h * 0.2);
            drawCtx.stroke();
            drawCtx.beginPath();
            drawCtx.moveTo(w * 0.2, -h * 0.05);
            drawCtx.lineTo(-w * 0.15, h * 0.2);
            drawCtx.stroke();
            drawCtx.shadowColor = color;
            drawCtx.fillStyle = color;
            drawCtx.beginPath();
            drawCtx.arc(0, -h * 0.38, w * 0.22, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.fillRect(-w * 0.28, -h * 0.35, w * 0.56, h * 0.06);
            drawCtx.fillStyle = '#ff0';
            drawCtx.shadowColor = '#ff0';
            drawCtx.fillRect(-w * 0.45, -h * 0.5, 2, h * 0.6);
            const flagWave = Math.sin(Date.now() / 200) * 3;
            drawCtx.beginPath();
            drawCtx.moveTo(-w * 0.43, -h * 0.5);
            drawCtx.lineTo(-w * 0.43 - 12 + flagWave, -h * 0.4);
            drawCtx.lineTo(-w * 0.43, -h * 0.3);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.strokeStyle = color;
            drawCtx.lineWidth = 1.5;
            drawCtx.beginPath();
            drawCtx.moveTo(w * 0.35, -h * 0.1);
            drawCtx.lineTo(w * 0.45, -h * 0.5);
            drawCtx.stroke();
            drawCtx.fillStyle = '#fff';
            drawCtx.beginPath();
            drawCtx.arc(w * 0.45, -h * 0.52, 2, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.fillStyle = '#f22';
            drawCtx.shadowColor = '#f22';
            drawCtx.globalAlpha = 0.8;
            const f = engineFlicker || 0;
            drawCtx.beginPath();
            drawCtx.moveTo(-6, h * 0.35);
            drawCtx.lineTo(0, h * 0.35 + 15 + f);
            drawCtx.lineTo(6, h * 0.35);
            drawCtx.closePath();
            drawCtx.fill();
            const wave = Math.sin(Date.now() / 100) * 4;
            drawCtx.beginPath();
            drawCtx.moveTo(-3 + wave, h * 0.4);
            drawCtx.lineTo(wave, h * 0.4 + 8 + f * 0.5);
            drawCtx.lineTo(3 + wave, h * 0.4);
            drawCtx.closePath();
            drawCtx.fill();
            drawCtx.globalAlpha = 1;
            drawCtx.restore();
        }

        function drawCharacter(drawCtx, charKey, x, y, w, h, color, engineFlicker) {
            switch (charKey) {
                case 'dredger': drawDredger(drawCtx, x, y, w, h, color, engineFlicker); break;
                case 'cleaner': drawCleaner(drawCtx, x, y, w, h, color, engineFlicker); break;
                case 'signal': drawSignal(drawCtx, x, y, w, h, color, engineFlicker); break;
            }
        }

        function drawPlayer() {
            if (!selectedChar) return;
            const charData = CHARACTERS[selectedChar];
            if (player.invincible && Math.floor(Date.now() / 100) % 2 === 0) return;
            const flicker = Math.random() * 5;
            drawCharacter(ctx, selectedChar, player.x, player.y, player.width, player.height, charData.color, flicker);
            if (player.invincible) {
                ctx.save();
                ctx.strokeStyle = charData.color;
                ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 100) * 0.2;
                ctx.lineWidth = 2;
                ctx.shadowColor = charData.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.width * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            if (player.buffed) {
                ctx.save();
                ctx.strokeStyle = '#ff0';
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 150) * 0.2;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.width * 0.9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }
        }

        // ========================================
        // ì , ì´ì•Œ, íŒŒí‹°í´, ë³„ ê·¸ë¦¬ê¸°
        // ========================================
        function drawEnemy(enemy) {
            ctx.save();
            ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            if (enemy.stunned) {
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
            }
            ctx.shadowColor = enemy.color;
            ctx.shadowBlur = 15;
            ctx.fillStyle = enemy.color;
            if (enemy.type === 'boss') {
                ctx.beginPath();
                ctx.moveTo(0, -enemy.height / 2);
                ctx.lineTo(enemy.width / 2, 0);
                ctx.lineTo(0, enemy.height / 2);
                ctx.lineTo(-enemy.width / 2, 0);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-6, -2, 3, 0, Math.PI * 2);
                ctx.arc(6, -2, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'mid') {
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI * 2) / 6 - Math.PI / 2;
                    const ex = Math.cos(angle) * enemy.width / 2;
                    const ey = Math.sin(angle) * enemy.height / 2;
                    if (i === 0) ctx.moveTo(ex, ey);
                    else ctx.lineTo(ex, ey);
                }
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.moveTo(0, enemy.height / 2);
                ctx.lineTo(-enemy.width / 2, -enemy.height / 2);
                ctx.lineTo(enemy.width / 2, -enemy.height / 2);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function drawBullet(bullet, isEnemy = false) {
            ctx.save();
            const bulletColor = isEnemy ? '#f00' : (selectedChar ? CHARACTERS[selectedChar].color : '#0ff');
            ctx.shadowColor = bulletColor;
            ctx.shadowBlur = 10;
            ctx.fillStyle = bulletColor;
            ctx.beginPath();
            ctx.ellipse(bullet.x, bullet.y, 3, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function createExplosion(x, y, color) {
            if (particles.length >= LIMITS.particles) {
                particles.splice(0, 15);
            }
            const count = Math.min(12, LIMITS.particles - particles.length);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = Math.random() * 4 + 2;
                particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 1, color });
            }
        }

        function drawStars() {
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                star.y += star.speed;
                if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; }
            });
        }

        function drawParticles() {
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                p.x += p.vx; p.y += p.vy; p.life -= 0.03;
            });
        }

        // ========================================
        // ì¶©ëŒ ê°ì§€
        // ========================================
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }
        function checkCircleCollision(cx, cy, radius, rect) {
            const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.height));
            const dx = cx - closestX; const dy = cy - closestY;
            return (dx * dx + dy * dy) < (radius * radius);
        }

        // ========================================
        // í™”ë©´: ì‹œì‘, ì„ íƒ, ê²Œì„ì˜¤ë²„
        // ========================================
        function drawStartScreen() {
            ctx.save();
            ctx.textAlign = 'center';
            ctx.fillStyle = '#f0f';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 30;
            ctx.font = 'bold 36px Courier New';
            ctx.fillText('DYlike', canvas.width / 2, canvas.height / 2 - 80);
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#0ff';
            ctx.font = '16px Courier New';
            ctx.fillText('ë””ì™€ì´ì‚°ì—…ê°œë°œ ìŠˆíŒ… ê²Œì„', canvas.width / 2, canvas.height / 2 - 45);
            ctx.fillStyle = '#888';
            ctx.shadowBlur = 0;
            ctx.font = '13px Courier New';
            if (isTouchDevice) {
                ctx.fillText('í•˜ë‹¨ ë²„íŠ¼ìœ¼ë¡œ ì¡°ì‘', canvas.width / 2, canvas.height / 2);
                ctx.fillText('â—€â–¶ ì´ë™ | FIRE ë°œì‚¬ | Z X C ìŠ¤í‚¬', canvas.width / 2, canvas.height / 2 + 22);
            } else {
                ctx.fillText('â† â†’ : ì´ë™  |  SPACE : ë°œì‚¬', canvas.width / 2, canvas.height / 2);
                ctx.fillText('Z / X / C : ìŠ¤í‚¬  |  F : ì „ì²´í™”ë©´', canvas.width / 2, canvas.height / 2 + 22);
            }
            ctx.fillStyle = '#ff0';
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 10;
            ctx.font = 'bold 22px Courier New';
            const blinkAlpha = Math.sin(Date.now() / 300) > 0 ? 1 : 0.3;
            ctx.globalAlpha = blinkAlpha;
            ctx.fillText(isTouchDevice ? 'â–¶ TAP TO START â—€' : 'CLICK or SPACE', canvas.width / 2, canvas.height / 2 + 80);
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function drawSelectScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.textAlign = 'center';
            ctx.fillStyle = '#f0f';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 20;
            ctx.font = 'bold 26px Courier New';
            ctx.fillText('ìºë¦­í„° ì„ íƒ', canvas.width / 2, 45);
            ctx.fillStyle = '#888';
            ctx.shadowBlur = 0;
            ctx.font = '12px Courier New';
            ctx.fillText('ë””ì™€ì´ì‚°ì—…ê°œë°œ íŠ¹ìˆ˜ë¶€ëŒ€', canvas.width / 2, 65);

            const cardWidth = 140;
            const cardHeight = 400;
            const gap = 10;
            const totalWidth = cardWidth * 3 + gap * 2;
            const startX = (canvas.width - totalWidth) / 2;
            const cardY = 80;
            selectAnimTimer += 0.03;

            CHARACTER_KEYS.forEach((key, i) => {
                const charData = CHARACTERS[key];
                const cx = startX + i * (cardWidth + gap) + cardWidth / 2;
                const cy = cardY;
                const isSelected = i === selectedCharIndex;

                if (isSelected) {
                    const glowSize = 3 + Math.sin(selectAnimTimer * 3) * 2;
                    ctx.save();
                    ctx.strokeStyle = charData.color;
                    ctx.shadowColor = charData.color;
                    ctx.shadowBlur = 20 + glowSize * 3;
                    ctx.lineWidth = 2 + glowSize * 0.5;
                    ctx.strokeRect(cx - cardWidth / 2 - 2, cy - 2, cardWidth + 4, cardHeight + 4);
                    ctx.restore();
                }

                ctx.fillStyle = isSelected ? 'rgba(255,255,255,0.08)' : 'rgba(255,255,255,0.03)';
                ctx.fillRect(cx - cardWidth / 2, cy, cardWidth, cardHeight);

                ctx.fillStyle = charData.color;
                ctx.shadowColor = charData.color;
                ctx.shadowBlur = isSelected ? 15 : 5;
                ctx.font = isSelected ? 'bold 17px Courier New' : '15px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(charData.name, cx, cy + 22);
                ctx.fillStyle = '#aaa'; ctx.shadowBlur = 0;
                ctx.font = '10px Courier New';
                ctx.fillText(charData.nameEn, cx, cy + 36);
                ctx.fillStyle = charData.color;
                ctx.font = '11px Courier New';
                ctx.fillText(charData.role, cx, cy + 52);

                const previewScale = isSelected ? 1.3 + Math.sin(selectAnimTimer * 2) * 0.1 : 1.0;
                ctx.save();
                ctx.scale(previewScale, previewScale);
                drawCharacter(ctx, key, cx / previewScale, (cy + 100) / previewScale, 40, 40, charData.color, Math.random() * 5);
                ctx.restore();

                const statY = cy + 145;
                const statLabels = ['ì†ë„', 'ê³µê²©', 'ì²´ë ¥'];
                const statValues = [charData.speed, charData.attack, charData.health];
                const statMax = [7, 3, 4];
                const statColors = ['#0f0', '#f80', '#f00'];
                statLabels.forEach((label, si) => {
                    const sy = statY + si * 25;
                    ctx.fillStyle = '#888'; ctx.font = '10px Courier New'; ctx.textAlign = 'left';
                    ctx.fillText(label, cx - cardWidth / 2 + 6, sy + 4);
                    const barX = cx - cardWidth / 2 + 40;
                    const barW = cardWidth - 48;
                    ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    ctx.fillRect(barX, sy - 5, barW, 9);
                    ctx.fillStyle = statColors[si];
                    ctx.shadowColor = statColors[si]; ctx.shadowBlur = isSelected ? 8 : 3;
                    ctx.fillRect(barX, sy - 5, (statValues[si] / statMax[si]) * barW, 9);
                    ctx.shadowBlur = 0;
                });

                const skillY = statY + 88;
                ctx.fillStyle = charData.color; ctx.font = 'bold 10px Courier New'; ctx.textAlign = 'center';
                ctx.fillText('â€” ìŠ¤í‚¬ â€”', cx, skillY);
                charData.skills.forEach((skill, si) => {
                    const sy = skillY + 18 + si * 42;
                    ctx.fillStyle = '#ff0'; ctx.font = 'bold 11px Courier New'; ctx.textAlign = 'center';
                    ctx.fillText(`[${skill.key}]`, cx, sy);
                    ctx.fillStyle = charData.color; ctx.font = '10px Courier New';
                    ctx.fillText(skill.name, cx, sy + 13);
                    ctx.fillStyle = '#888'; ctx.font = '9px Courier New';
                    ctx.fillText(skill.desc, cx, sy + 25);
                });
            });

            // í•˜ë‹¨ ì•ˆë‚´
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ff0'; ctx.shadowColor = '#ff0'; ctx.shadowBlur = 10;
            ctx.font = 'bold 16px Courier New';
            ctx.globalAlpha = Math.sin(Date.now() / 300) > 0 ? 1 : 0.3;
            if (isTouchDevice) {
                ctx.fillText('ìºë¦­í„°ë¥¼ íƒ­í•˜ì„¸ìš”!', canvas.width / 2, canvas.height - 20);
            } else {
                ctx.fillText('â† â†’ ì„ íƒ  |  SPACE í™•ì •', canvas.width / 2, canvas.height - 20);
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function drawGameOverScreen() {
            ctx.save();
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f0f'; ctx.shadowColor = '#f0f'; ctx.shadowBlur = 30;
            ctx.font = 'bold 44px Courier New';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);
            ctx.fillStyle = '#0ff'; ctx.shadowColor = '#0ff'; ctx.shadowBlur = 10;
            ctx.font = '22px Courier New';
            ctx.fillText(`ìµœì¢… ì ìˆ˜: ${score}`, canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText(`ìµœê³  ê¸°ë¡: ${highScore}`, canvas.width / 2, canvas.height / 2 + 25);
            ctx.fillStyle = '#ff0'; ctx.shadowColor = '#ff0';
            ctx.font = 'bold 18px Courier New';
            ctx.globalAlpha = Math.sin(Date.now() / 300) > 0 ? 1 : 0.3;
            ctx.fillText(isTouchDevice ? 'â–¶ TAP TO RETRY â—€' : 'CLICK or SPACE', canvas.width / 2, canvas.height / 2 + 80);
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        // ========================================
        // ìŠ¤í‚¬ ì‹œìŠ¤í…œ
        // ========================================
        function drawSkillUI() {
            if (!selectedChar) return;
            const charData = CHARACTERS[selectedChar];
            const iconSize = 38; const gap = 12;
            const totalW = 3 * iconSize + 2 * gap;
            const startX = (canvas.width - totalW) / 2;
            const y = canvas.height - 42;
            ctx.save();
            charData.skills.forEach((skill, i) => {
                const sx = startX + i * (iconSize + gap);
                const cooldownLeft = skillCooldowns[i];
                const isReady = cooldownLeft <= 0;
                const isAct = skillActive[i];
                ctx.fillStyle = isAct ? 'rgba(255,255,0,0.3)' : (isReady ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.05)');
                ctx.fillRect(sx, y, iconSize, iconSize);
                ctx.strokeStyle = isAct ? '#ff0' : (isReady ? charData.color : '#555');
                ctx.lineWidth = isAct ? 2 : 1;
                if (isReady) { ctx.shadowColor = charData.color; ctx.shadowBlur = 8; }
                ctx.strokeRect(sx, y, iconSize, iconSize);
                ctx.shadowBlur = 0;
                ctx.fillStyle = isReady ? '#ff0' : '#666';
                ctx.font = 'bold 13px Courier New'; ctx.textAlign = 'center';
                ctx.fillText(skill.key, sx + iconSize / 2, y + 15);
                ctx.fillStyle = isReady ? charData.color : '#555';
                ctx.font = '8px Courier New';
                ctx.fillText(skill.name.substring(0, 4), sx + iconSize / 2, y + 28);
                if (!isReady && !isAct) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(sx, y, iconSize, iconSize * (cooldownLeft / skill.cooldown));
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 11px Courier New'; ctx.textAlign = 'center';
                    ctx.fillText(Math.ceil(cooldownLeft / 1000) + 's', sx + iconSize / 2, y + iconSize / 2 + 4);
                }
            });
            ctx.restore();
        }

        function activateSkill(skillIndex) {
            if (!selectedChar) return;
            if (skillCooldowns[skillIndex] > 0) return;
            if (skillActive[skillIndex]) return;
            const skill = CHARACTERS[selectedChar].skills[skillIndex];
            skillActive[skillIndex] = true;
            skillActiveTimer[skillIndex] = skill.duration;
            skillCooldowns[skillIndex] = skill.cooldown;
            executeSkillEffect(selectedChar, skillIndex);
        }

        function executeSkillEffect(charKey, skillIndex) {
            switch (charKey) {
                case 'dredger': executeDredgerSkill(skillIndex); break;
                case 'cleaner': executeCleanerSkill(skillIndex); break;
                case 'signal': executeSignalSkill(skillIndex); break;
            }
        }

        function executeDredgerSkill(index) {
            if (skillEffects.length >= LIMITS.skillEffects) return;
            switch (index) {
                case 0:
                    skillEffects.push({ type: 'suction', x: player.x, y: player.y, timer: 2000, radius: 120, angle: Math.PI * 0.6 });
                    break;
                case 1:
                    skillEffects.push({ type: 'waterCannon', x: player.x, y: player.y, timer: 500, width: 30, damage: 5 });
                    break;
                case 2:
                    player.invincible = true; player.invincibleTimer = 3000;
                    skillEffects.push({ type: 'gasShield', x: player.x, y: player.y, timer: 3000, radius: 50 });
                    break;
            }
        }

        function executeCleanerSkill(index) {
            if (skillEffects.length >= LIMITS.skillEffects) return;
            switch (index) {
                case 0:
                    skillEffects.push({ type: 'hydroCannon', x: player.x, y: player.y, timer: 300, width: 8, damage: 8 });
                    break;
                case 1:
                    skillEffects.push({ type: 'spinWash', x: player.x, y: player.y, timer: 500, radius: 100, angle: 0, damage: 3 });
                    break;
                case 2:
                    skillEffects.push({ type: 'corrosion', x: player.x, y: player.y - 60, timer: 5000, radius: 50, damage: 1, damageTimer: 0 });
                    break;
            }
        }

        function executeSignalSkill(index) {
            switch (index) {
                case 0:
                    enemyStunTimer = 2000;
                    enemies.forEach(e => e.stunned = true);
                    if (skillEffects.length < LIMITS.skillEffects)
                        skillEffects.push({ type: 'emergencyStop', timer: 500, flash: 1 });
                    break;
                case 1:
                    if (skillEffects.length >= LIMITS.skillEffects) return;
                    let targetX = canvas.width / 2, targetY = canvas.height / 3;
                    if (enemies.length > 0) {
                        let bestX = 0, bestY = 0, bestCount = 0;
                        enemies.forEach(e => {
                            let count = 0;
                            enemies.forEach(e2 => {
                                const dx = (e.x + e.width/2) - (e2.x + e2.width/2);
                                const dy = (e.y + e.height/2) - (e2.y + e2.height/2);
                                if (dx*dx + dy*dy < 80*80) count++;
                            });
                            if (count > bestCount) { bestCount = count; bestX = e.x + e.width/2; bestY = e.y + e.height/2; }
                        });
                        targetX = bestX; targetY = bestY;
                    }
                    skillEffects.push({ type: 'skyDrop', x: targetX, y: 0, targetY, timer: 800, radius: 70, damage: 10, phase: 'falling' });
                    break;
                case 2:
                    player.buffed = true; player.buffTimer = 5000; player.buffSpeedMult = 1.3; player.buffFireMult = 0.5;
                    if (skillEffects.length < LIMITS.skillEffects)
                        skillEffects.push({ type: 'commandSignal', x: player.x, y: player.y, timer: 1000, radius: 60 });
                    break;
            }
        }

        // ========================================
        // ìŠ¤í‚¬ ì´í™íŠ¸ ì—…ë°ì´íŠ¸ & ê·¸ë¦¬ê¸°
        // ========================================
        function updateSkillEffects(dt) {
            for (let i = skillEffects.length - 1; i >= 0; i--) {
                const fx = skillEffects[i];
                fx.timer -= dt;
                switch (fx.type) {
                    case 'suction':
                        fx.x = player.x; fx.y = player.y;
                        for (let bi = enemyBullets.length - 1; bi >= 0; bi--) {
                            const b = enemyBullets[bi];
                            const dx = b.x - fx.x, dy = b.y - fx.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < fx.radius && dy < 0 && Math.abs(Math.atan2(-dy, dx)) < fx.angle / 2) {
                                b.x -= dx * 0.1; b.y -= dy * 0.1;
                                if (dist < 20) {
                                    enemyBullets.splice(bi, 1);
                                    if (particles.length < LIMITS.particles)
                                        particles.push({ x: b.x, y: b.y, vx: (Math.random()-0.5)*2, vy: -Math.random()*2, life: 0.5, color: '#0ff' });
                                }
                            }
                        }
                        break;
                    case 'waterCannon':
                        fx.x = player.x;
                        for (let ei = enemies.length - 1; ei >= 0; ei--) {
                            const e = enemies[ei];
                            if (Math.abs(e.x + e.width/2 - fx.x) < fx.width/2 + e.width/2 && e.y < player.y) {
                                e.health -= fx.damage * dt / 500;
                                if (e.health <= 0) { createExplosion(e.x+e.width/2, e.y+e.height/2, e.color); enemies.splice(ei,1); score += e.type==='boss'?100:(e.type==='mid'?50:20); updateUI(); }
                            }
                        }
                        break;
                    case 'gasShield': fx.x = player.x; fx.y = player.y; break;
                    case 'hydroCannon':
                        fx.x = player.x;
                        for (let ei = enemies.length - 1; ei >= 0; ei--) {
                            const e = enemies[ei];
                            if (Math.abs(e.x+e.width/2-fx.x) < fx.width+e.width/2 && e.y < player.y) {
                                e.health -= fx.damage * dt / 300;
                                if (e.health <= 0) { createExplosion(e.x+e.width/2,e.y+e.height/2,e.color); enemies.splice(ei,1); score+=e.type==='boss'?100:(e.type==='mid'?50:20); updateUI(); }
                            }
                        }
                        break;
                    case 'spinWash':
                        fx.x = player.x; fx.y = player.y; fx.angle += dt * 0.015;
                        for (let ei = enemies.length - 1; ei >= 0; ei--) {
                            const e = enemies[ei];
                            if (checkCircleCollision(fx.x, fx.y, fx.radius, {x:e.x,y:e.y,width:e.width,height:e.height})) {
                                e.health -= fx.damage * dt / 500;
                                if (e.health <= 0) { createExplosion(e.x+e.width/2,e.y+e.height/2,e.color); enemies.splice(ei,1); score+=e.type==='boss'?100:(e.type==='mid'?50:20); updateUI(); }
                            }
                        }
                        break;
                    case 'corrosion':
                        fx.damageTimer -= dt;
                        if (fx.damageTimer <= 0) {
                            fx.damageTimer = 500;
                            for (let ei = enemies.length - 1; ei >= 0; ei--) {
                                const e = enemies[ei];
                                if (checkCircleCollision(fx.x, fx.y, fx.radius, {x:e.x,y:e.y,width:e.width,height:e.height})) {
                                    e.health -= fx.damage;
                                    if (e.health <= 0) { createExplosion(e.x+e.width/2,e.y+e.height/2,'#0f0'); enemies.splice(ei,1); score+=e.type==='boss'?100:(e.type==='mid'?50:20); updateUI(); }
                                }
                            }
                        }
                        break;
                    case 'emergencyStop': fx.flash -= dt / 500; break;
                    case 'skyDrop':
                        if (fx.phase === 'falling') {
                            fx.y += (fx.targetY - fx.y) * 0.15;
                            if (Math.abs(fx.y - fx.targetY) < 5) {
                                fx.phase = 'exploding';
                                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                                    const e = enemies[ei];
                                    if (checkCircleCollision(fx.x, fx.y, fx.radius, {x:e.x,y:e.y,width:e.width,height:e.height})) {
                                        e.health -= fx.damage;
                                        if (e.health <= 0) { createExplosion(e.x+e.width/2,e.y+e.height/2,'#ff0'); enemies.splice(ei,1); score+=e.type==='boss'?100:(e.type==='mid'?50:20); updateUI(); }
                                    }
                                }
                                createExplosion(fx.x, fx.y, '#ff0');
                                createExplosion(fx.x, fx.y, '#f80');
                            }
                        }
                        break;
                    case 'commandSignal': fx.x = player.x; fx.y = player.y; break;
                }
                if (fx.timer <= 0) skillEffects.splice(i, 1);
            }
        }

        function drawSkillEffects() {
            skillEffects.forEach(fx => {
                ctx.save();
                switch (fx.type) {
                    case 'suction':
                        ctx.globalAlpha = 0.3 + Math.sin(Date.now()/100)*0.1;
                        ctx.fillStyle = '#0ff'; ctx.shadowColor = '#0ff'; ctx.shadowBlur = 15;
                        ctx.beginPath(); ctx.moveTo(fx.x, fx.y);
                        ctx.arc(fx.x, fx.y, fx.radius, -Math.PI/2-fx.angle/2, -Math.PI/2+fx.angle/2);
                        ctx.closePath(); ctx.fill();
                        ctx.strokeStyle = '#0ff'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
                        for (let a = 0; a < 5; a++) {
                            const ang = -Math.PI/2-fx.angle/2+(fx.angle/4)*a;
                            const r = fx.radius*(0.5+Math.sin(Date.now()/200+a)*0.3);
                            ctx.beginPath(); ctx.moveTo(fx.x,fx.y); ctx.lineTo(fx.x+Math.cos(ang)*r, fx.y+Math.sin(ang)*r); ctx.stroke();
                        }
                        break;
                    case 'waterCannon': {
                        const g = ctx.createLinearGradient(fx.x, player.y, fx.x, 0);
                        g.addColorStop(0, 'rgba(0,255,255,0.8)'); g.addColorStop(1, 'rgba(0,255,255,0.1)');
                        ctx.fillStyle = g; ctx.shadowColor = '#0ff'; ctx.shadowBlur = 20;
                        const w = Math.sin(Date.now()/50)*3;
                        ctx.beginPath(); ctx.moveTo(fx.x-fx.width/2+w,player.y-20); ctx.lineTo(fx.x-fx.width/3,0);
                        ctx.lineTo(fx.x+fx.width/3,0); ctx.lineTo(fx.x+fx.width/2-w,player.y-20); ctx.closePath(); ctx.fill();
                        break; }
                    case 'gasShield': {
                        ctx.globalAlpha = 0.3+Math.sin(Date.now()/150)*0.15;
                        const g = ctx.createRadialGradient(fx.x,fx.y,0,fx.x,fx.y,fx.radius);
                        g.addColorStop(0,'rgba(0,255,100,0.4)'); g.addColorStop(0.7,'rgba(0,255,100,0.15)'); g.addColorStop(1,'rgba(0,255,100,0)');
                        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(fx.x,fx.y,fx.radius,0,Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#0f8';
                        for (let gp = 0; gp < 6; gp++) {
                            const ga = (Date.now()/500+gp*Math.PI/3)%(Math.PI*2);
                            const gr = fx.radius*0.7+Math.sin(Date.now()/200+gp)*10;
                            ctx.globalAlpha = 0.4; ctx.beginPath(); ctx.arc(fx.x+Math.cos(ga)*gr,fx.y+Math.sin(ga)*gr,4,0,Math.PI*2); ctx.fill();
                        }
                        break; }
                    case 'hydroCannon':
                        ctx.globalAlpha = 0.9; ctx.strokeStyle = '#f80'; ctx.shadowColor = '#f80'; ctx.shadowBlur = 25;
                        ctx.lineWidth = fx.width; ctx.beginPath(); ctx.moveTo(fx.x,player.y-20); ctx.lineTo(fx.x,0); ctx.stroke();
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(fx.x,player.y-20); ctx.lineTo(fx.x,0); ctx.stroke();
                        break;
                    case 'spinWash':
                        ctx.globalAlpha = 0.4; ctx.strokeStyle = '#f80'; ctx.shadowColor = '#f80'; ctx.shadowBlur = 15; ctx.lineWidth = 4;
                        for (let s = 0; s < 4; s++) {
                            const sa = fx.angle+s*Math.PI/2;
                            ctx.beginPath(); ctx.moveTo(fx.x,fx.y); ctx.lineTo(fx.x+Math.cos(sa)*fx.radius,fx.y+Math.sin(sa)*fx.radius); ctx.stroke();
                        }
                        ctx.globalAlpha = 0.2; ctx.beginPath(); ctx.arc(fx.x,fx.y,fx.radius,0,Math.PI*2); ctx.stroke();
                        break;
                    case 'corrosion': {
                        ctx.globalAlpha = 0.4+Math.sin(Date.now()/300)*0.1;
                        const g = ctx.createRadialGradient(fx.x,fx.y,0,fx.x,fx.y,fx.radius);
                        g.addColorStop(0,'rgba(0,255,0,0.6)'); g.addColorStop(0.5,'rgba(100,255,0,0.3)'); g.addColorStop(1,'rgba(0,200,0,0)');
                        ctx.fillStyle = g; ctx.beginPath(); ctx.ellipse(fx.x,fx.y,fx.radius,fx.radius*0.5,0,0,Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#0f0';
                        for (let b = 0; b < 3; b++) {
                            const bx = fx.x+Math.sin(Date.now()/300+b*2)*fx.radius*0.5;
                            const by = fx.y+Math.cos(Date.now()/250+b*1.5)*fx.radius*0.3;
                            ctx.globalAlpha = 0.5+Math.sin(Date.now()/200+b)*0.3;
                            ctx.beginPath(); ctx.arc(bx,by,3+Math.sin(Date.now()/400+b)*2,0,Math.PI*2); ctx.fill();
                        }
                        break; }
                    case 'emergencyStop':
                        ctx.globalAlpha = fx.flash*0.5; ctx.fillStyle = '#f22'; ctx.fillRect(0,0,canvas.width,canvas.height);
                        if (fx.flash > 0.3) { ctx.globalAlpha = fx.flash; ctx.fillStyle = '#fff'; ctx.font = 'bold 40px Courier New'; ctx.textAlign = 'center'; ctx.fillText('âš  STOP âš ', canvas.width/2, canvas.height/2); }
                        break;
                    case 'skyDrop':
                        if (fx.phase === 'falling') {
                            ctx.fillStyle = '#ff0'; ctx.shadowColor = '#ff0'; ctx.shadowBlur = 15;
                            ctx.fillRect(fx.x-15,fx.y-15,30,30);
                            ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(fx.x,fx.y-15); ctx.lineTo(fx.x,0); ctx.stroke();
                            ctx.globalAlpha = 0.3; ctx.strokeStyle = '#f00'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
                            ctx.beginPath(); ctx.arc(fx.x,fx.targetY,fx.radius,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
                        } else {
                            const ea = fx.timer/300; ctx.globalAlpha = ea*0.5; ctx.fillStyle = '#ff0'; ctx.shadowColor = '#ff0'; ctx.shadowBlur = 30;
                            ctx.beginPath(); ctx.arc(fx.x,fx.targetY,fx.radius*(1+(1-ea)*0.5),0,Math.PI*2); ctx.fill();
                        }
                        break;
                    case 'commandSignal':
                        ctx.globalAlpha = fx.timer/1000; ctx.strokeStyle = '#ff0'; ctx.shadowColor = '#ff0'; ctx.shadowBlur = 15; ctx.lineWidth = 2;
                        const rr = fx.radius*(1-fx.timer/1000)+20;
                        ctx.beginPath(); ctx.arc(fx.x,fx.y,rr,0,Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.arc(fx.x,fx.y,rr*0.7,0,Math.PI*2); ctx.stroke();
                        break;
                }
                ctx.restore();
            });
        }

        // ========================================
        // ê²Œì„ ì—…ë°ì´íŠ¸
        // ========================================
        function update(dt) {
            if (gameState !== 'playing') return;
            const charData = selectedChar ? CHARACTERS[selectedChar] : null;
            const currentSpeed = charData ? charData.speed * (player.buffed ? player.buffSpeedMult : 1) : 6;
            const currentShootCd = charData ? charData.shootCooldown * (player.buffed ? player.buffFireMult : 1) : 200;

            if (keys.left && player.x > player.width / 2) player.x -= currentSpeed;
            if (keys.right && player.x < canvas.width - player.width / 2) player.x += currentSpeed;

            if (keys.space && Date.now() - lastShot > currentShootCd && bullets.length < LIMITS.playerBullets) {
                bullets.push({ x: player.x, y: player.y - player.height / 2, speed: 10 });
                lastShot = Date.now();
            }

            bullets = bullets.filter(b => b.y > 0);
            bullets.forEach(b => b.y -= b.speed);
            enemyBullets = enemyBullets.filter(b => b.y < canvas.height);
            enemyBullets.forEach(b => b.y += b.speed);

            if (enemyStunTimer > 0) {
                enemyStunTimer -= dt;
                if (enemyStunTimer <= 0) { enemyStunTimer = 0; enemies.forEach(e => e.stunned = false); }
            }

            let moveDown = false;
            enemies.forEach(enemy => {
                if (enemy.stunned) return;
                enemy.x += enemy.moveDir * (1 + level * 0.2);
                if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) moveDown = true;
                if (enemyBullets.length < LIMITS.enemyBullets && Math.random() < 0.001 * level) {
                    enemyBullets.push({ x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height, speed: 4 + level * 0.5 });
                }
            });
            if (moveDown) {
                enemies.forEach(enemy => { if (!enemy.stunned) { enemy.moveDir *= -1; enemy.y += 20; } });
            }

            for (let bi = bullets.length - 1; bi >= 0; bi--) {
                const bullet = bullets[bi]; if (!bullet) continue;
                const br = { x: bullet.x-3, y: bullet.y-8, width: 6, height: 16 };
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const enemy = enemies[ei]; if (!enemy) continue;
                    if (checkCollision(br, { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height })) {
                        bullets.splice(bi, 1);
                        enemy.health -= charData ? charData.attack : 1;
                        if (enemy.health <= 0) { createExplosion(enemy.x+enemy.width/2,enemy.y+enemy.height/2,enemy.color); enemies.splice(ei,1); score+=enemy.type==='boss'?100:(enemy.type==='mid'?50:20); updateUI(); }
                        break;
                    }
                }
            }

            if (!player.invincible) {
                const pr = { x: player.x-player.width/2, y: player.y-player.height/2, width: player.width, height: player.height };
                for (let bi = enemyBullets.length - 1; bi >= 0; bi--) {
                    const bullet = enemyBullets[bi]; if (!bullet) continue;
                    if (checkCollision({ x: bullet.x-3, y: bullet.y-8, width: 6, height: 16 }, pr)) {
                        enemyBullets.splice(bi, 1); lives--;
                        createExplosion(player.x, player.y, player.color); updateUI();
                        if (lives <= 0) { doGameOver(); } else { player.invincible = true; player.invincibleTimer = 1500; }
                    }
                }
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const enemy = enemies[ei]; if (!enemy) continue;
                    if (checkCollision(pr, { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height })) {
                        createExplosion(enemy.x+enemy.width/2,enemy.y+enemy.height/2,enemy.color); enemies.splice(ei,1);
                        lives--; updateUI();
                        if (lives <= 0) { doGameOver(); } else { player.invincible = true; player.invincibleTimer = 1500; }
                    }
                    if (enemy && enemy.y + enemy.height > player.y) doGameOver();
                }
            }

            if (player.invincible) { player.invincibleTimer -= dt; if (player.invincibleTimer <= 0) { player.invincible = false; } }
            if (player.buffed) { player.buffTimer -= dt; if (player.buffTimer <= 0) { player.buffed = false; player.buffSpeedMult = 1; player.buffFireMult = 1; } }

            for (let i = 0; i < 3; i++) {
                if (skillCooldowns[i] > 0) { skillCooldowns[i] -= dt; if (skillCooldowns[i] < 0) skillCooldowns[i] = 0; }
                if (skillActive[i]) { skillActiveTimer[i] -= dt; if (skillActiveTimer[i] <= 0) { skillActive[i] = false; } }
            }
            if (keys.z) { activateSkill(0); keys.z = false; }
            if (keys.x) { activateSkill(1); keys.x = false; }
            if (keys.c) { activateSkill(2); keys.c = false; }
            updateSkillEffects(dt);

            if (enemies.length === 0) { level++; updateUI(); spawnEnemies(); }
        }

        function updateUI() {
            scoreEl.textContent = `SCORE: ${score}`;
            livesEl.textContent = `LIVES: ${'â™¥'.repeat(Math.max(0,lives))}${'â™¡'.repeat(Math.max(0,maxLives-lives))}`;
            levelEl.textContent = `LEVEL: ${level}`;
        }

        function doGameOver() {
            gameState = 'gameover';
            if (score > highScore) { highScore = score; localStorage.setItem('galaga-highscore', highScore); }
        }

        function startGame() {
            gameState = 'playing'; score = 0;
            const charData = CHARACTERS[selectedChar];
            lives = charData.health; maxLives = charData.health; level = 1;
            player.x = canvas.width / 2; player.y = canvas.height - 60;
            player.color = charData.color; player.speed = charData.speed;
            player.invincible = false; player.invincibleTimer = 0;
            player.buffed = false; player.buffTimer = 0; player.buffSpeedMult = 1; player.buffFireMult = 1;
            bullets = []; enemies = []; particles = []; enemyBullets = []; skillEffects = [];
            skillCooldowns = [0,0,0]; skillActive = [false,false,false]; skillActiveTimer = [0,0,0]; enemyStunTimer = 0;
            updateUI(); spawnEnemies();
        }

        // ========================================
        // ê·¸ë¦¬ê¸°
        // ========================================
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawStars();

            if (gameState === 'start') { drawStartScreen(); }
            else if (gameState === 'select') { drawSelectScreen(); }
            else if (gameState === 'playing') {
                drawSkillEffects(); drawPlayer();
                enemies.forEach(e => drawEnemy(e));
                bullets.forEach(b => drawBullet(b));
                enemyBullets.forEach(b => drawBullet(b, true));
                drawParticles(); drawSkillUI();
            } else if (gameState === 'gameover') {
                drawPlayer(); enemies.forEach(e => drawEnemy(e));
                bullets.forEach(b => drawBullet(b)); enemyBullets.forEach(b => drawBullet(b, true));
                drawParticles(); drawGameOverScreen();
            }
        }

        // ========================================
        // ê²Œì„ ë£¨í”„
        // ========================================
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if (deltaTime > 100) deltaTime = 16;
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ========================================
        // ê³µí†µ: ìƒíƒœ ì „í™˜ í•¨ìˆ˜
        // ========================================
        function handleAction() {
            if (gameState === 'start') {
                gameState = 'select';
            } else if (gameState === 'select') {
                selectedChar = CHARACTER_KEYS[selectedCharIndex];
                startGame();
            } else if (gameState === 'gameover') {
                gameState = 'select';
            }
        }

        // ========================================
        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        // ========================================
        document.addEventListener('keydown', (e) => {
            canvas.focus();
            if (e.code === 'ArrowLeft') keys.left = true;
            if (e.code === 'ArrowRight') keys.right = true;
            if (e.code === 'Space') {
                e.preventDefault();
                keys.space = true;
                handleAction();
            }
            if (e.code === 'KeyZ') { e.preventDefault(); keys.z = true; }
            if (e.code === 'KeyX') { e.preventDefault(); keys.x = true; }
            if (e.code === 'KeyC') { e.preventDefault(); keys.c = true; }
            if (e.code === 'KeyF') { e.preventDefault(); toggleFullscreen(); }
            if (gameState === 'select') {
                if (e.code === 'ArrowLeft') selectedCharIndex = (selectedCharIndex - 1 + CHARACTER_KEYS.length) % CHARACTER_KEYS.length;
                if (e.code === 'ArrowRight') selectedCharIndex = (selectedCharIndex + 1) % CHARACTER_KEYS.length;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.left = false;
            if (e.code === 'ArrowRight') keys.right = false;
            if (e.code === 'Space') keys.space = false;
        });

        // ========================================
        // ë§ˆìš°ìŠ¤/í´ë¦­ ì´ë²¤íŠ¸
        // ========================================
        canvas.addEventListener('click', (e) => {
            canvas.focus();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            if (gameState === 'start' || gameState === 'gameover') {
                handleAction();
            } else if (gameState === 'select') {
                const cardWidth = 140, gap = 10;
                const totalWidth = cardWidth * 3 + gap * 2;
                const startX = (canvas.width - totalWidth) / 2;
                const cardY = 80, cardHeight = 400;
                for (let i = 0; i < 3; i++) {
                    const cx = startX + i * (cardWidth + gap);
                    if (clickX >= cx && clickX <= cx + cardWidth && clickY >= cardY && clickY <= cardY + cardHeight) {
                        if (selectedCharIndex === i) {
                            handleAction();
                        } else {
                            selectedCharIndex = i;
                        }
                        return;
                    }
                }
                handleAction();
            }
        });

        // ========================================
        // í„°ì¹˜ ì»¨íŠ¸ë¡¤ (ëª¨ë°”ì¼)
        // ========================================
        function setupTouchBtn(id, keyName, isToggle) {
            const btn = document.getElementById(id);
            if (!btn) return;
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                keys[keyName] = true;
                btn.classList.add('pressed');
                if (keyName === 'space') handleAction();
            }, { passive: false });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!isToggle) {
                    keys[keyName] = false;
                }
                btn.classList.remove('pressed');
            }, { passive: false });
            // touchcancelë„ ì²˜ë¦¬ (ì†ê°€ë½ì´ ë²„íŠ¼ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ë•Œ)
            btn.addEventListener('touchcancel', (e) => {
                keys[keyName] = false;
                btn.classList.remove('pressed');
            }, { passive: false });
        }

        setupTouchBtn('btnLeft', 'left', false);
        setupTouchBtn('btnRight', 'right', false);
        setupTouchBtn('btnFire', 'space', false);
        setupTouchBtn('btnSkillZ', 'z', true);
        setupTouchBtn('btnSkillX', 'x', true);
        setupTouchBtn('btnSkillC', 'c', true);

        // ìº”ë²„ìŠ¤ í„°ì¹˜ (ì‹œì‘/ì„ íƒ/ê²Œì„ì˜¤ë²„)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            canvas.focus();
            if (gameState === 'start' || gameState === 'gameover') {
                handleAction();
            } else if (gameState === 'select') {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touchX = (e.touches[0].clientX - rect.left) * scaleX;
                const touchY = (e.touches[0].clientY - rect.top) * scaleY;
                const cardWidth = 140, gap = 10;
                const totalWidth = cardWidth * 3 + gap * 2;
                const startX = (canvas.width - totalWidth) / 2;
                const cardY2 = 80, cardHeight2 = 400;
                for (let i = 0; i < 3; i++) {
                    const cx = startX + i * (cardWidth + gap);
                    if (touchX >= cx && touchX <= cx + cardWidth && touchY >= cardY2 && touchY <= cardY2 + cardHeight2) {
                        if (selectedCharIndex === i) { handleAction(); }
                        else { selectedCharIndex = i; }
                        return;
                    }
                }
                handleAction();
            }
        }, { passive: false });

        // ëª¨ë°”ì¼ ìë™ ì „ì²´í™”ë©´ ì œì•ˆ (ì²« í„°ì¹˜ì—)
        if (isTouchDevice) {
            let fullscreenPrompted = false;
            document.addEventListener('touchstart', function promptFS() {
                if (!fullscreenPrompted && !document.fullscreenElement && !document.webkitFullscreenElement) {
                    fullscreenPrompted = true;
                    // ì•½ê°„ì˜ ì§€ì—° í›„ ì „ì²´í™”ë©´ ì‹œë„ (ìœ ì € ì œìŠ¤ì²˜ ë‚´)
                    setTimeout(() => {
                        const el = document.documentElement;
                        if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
                        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                        setTimeout(resizeCanvas, 300);
                    }, 100);
                    document.removeEventListener('touchstart', promptFS);
                }
            }, { passive: true });
        }

        // ========================================
        // ì´ˆê¸°í™”
        // ========================================
        initStars();
        canvas.focus();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
